(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{592:function(t,a,e){"use strict";e.r(a);var n=e(41),s=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("div",{staticClass:"center-container"},[e("p",[e("img",{attrs:{src:"https://image.iluoli.ren/2022/01/26/d16c617a10ae9.png",alt:""}})])]),e("div",{staticClass:"custom-block theorem"},[e("p",{staticClass:"title"},[t._v("本文转载自：")]),e("p",[t._v("Linux Jargon Buster: What are Upstream and Downstream?")]),t._v(" "),e("div",{staticClass:"custom-block right"},[e("p",[t._v("via "),e("a",{attrs:{href:"https://itsfoss.com/upstream-and-downstream-linux/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Bill Dyer"),e("OutboundLink")],1)]),t._v(" "),e("div",{staticClass:"custom-block right"},[e("p",[t._v("translator："),e("a",{attrs:{href:"https://linux.cn/article-14215-1.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Linux中国"),e("OutboundLink")],1)])])])]),e("p",[t._v("上游"),e("Badge",{attrs:{text:"upstream"}}),t._v("和 下游"),e("Badge",{attrs:{text:"downstream"}}),t._v("这两个术语是相当模糊的，我认为一般人并不会真正使用它们。如果你只是一个 Linux 用户，并且不编写或维护软件，那么很有可能这些术语对你来说毫无意义，但它们对 Linux 世界中各个社区之间的交流方式有益的。")],1),t._v(" "),e("p",[t._v("这些术语被用于网络、编程、内核，甚至在非计算机领域，如供应链。当我们谈论上游和下游的时候，讨论背景是很重要的。")]),t._v(" "),e("p",[t._v("在其最简单的形式中，上游和下游是信息流动的方向。")]),t._v(" "),e("p",[t._v("由于我们都是在连接到互联网的情况下阅读这篇文章的，让我们看看适用于互联网服务提供商（ISP）的上游/下游例子。这里，ISP 关注的是流量。上游流量是指数据是从不同的 ISP 的用户处传来的。例如，如果你有一个提供订阅通讯的网站，我发送的订阅信息就是上游数据。")]),t._v(" "),e("p",[t._v("下游流量是指从一个用户发送到不同 ISP 的另一个用户的数据，它被认为是下游流量。使用同样的订阅例子，假设我的订阅请求被批准，我在一封邮件中收到“欢迎”说明，在又一封邮件中收到最新的新闻简报。在这种情况下，数据是顺流而下的，因为它是由你（好吧，可能是作为代表你进行操作的自动化软件）发送给我，一个来自另外 ISP 的用户。")]),t._v(" "),e("p",[t._v("总结：我需要或想要的东西（你的通讯）是上游的。你提供给我的东西（欢迎词和实际的通讯）是下游的。")]),t._v(" "),e("p",[t._v("数据是在上游还是在下游，对我们用户来说可能并不重要，但对监控带宽使用的服务器管理员，以及发行商"),e("Badge",{attrs:{text:"distributor"}}),t._v("（发行版的制作者）和程序员来说却很重要。")],1),t._v(" "),e("p",[t._v("在 Linux 世界里，上游和下游有两个主要背景。一个是关于内核的，另一个是关于应用程序的。还有其他的，但我希望我可以通过这两个来表达我的想法。")]),t._v(" "),e("h2",{attrs:{id:"linux-内核背景下的上游和下游"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linux-内核背景下的上游和下游"}},[t._v("#")]),t._v(" Linux 内核背景下的上游和下游")]),t._v(" "),e("p",[t._v("Linux 就是 内核。在创建发行版时，Linux 发行版首先使用未经修改的内核源代码。然后添加必要的补丁，对内核进行配置。内核的配置是基于发行版想要提供的功能和选项。一旦决定了，就相应地创建了内核。")]),t._v(" "),e("p",[t._v("原始内核来自发行版的上游。当发行版得到源代码时，它就流向下游。一旦发行版得到了内核代码，它就会留在发行商那里，同时对它进行改造。它仍然是我们用户的上游，直到它准备好被发布。")]),t._v(" "),e("p",[t._v("发行版创建的内核版本将添加补丁和启用某些功能和选项。这种配置是由发行商决定的。这就是为什么有几种 Linux 流派的原因，例如，Debian 与 Red Hat。发行商会决定向他们的用户群提供哪些选项，并相应地编译内核。")]),t._v(" "),e("p",[t._v("一旦这项工作完成，它就会放在一个仓库中准备发布，我们就可以获得一份副本。这个副本向下游流向我们。")]),t._v(" "),e("p",[t._v("同样地，如果发行商发现了内核中的一个错误，修复了它，然后将补丁发送给内核开发者，这样他们就可以为下游的每个人修补内核。这被称为对上游的贡献，因为这里的流量是向上流向原始来源的。")]),t._v(" "),e("h2",{attrs:{id:"在应用程序背景下的上游和下游"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在应用程序背景下的上游和下游"}},[t._v("#")]),t._v(" 在应用程序背景下的上游和下游")]),t._v(" "),e("p",[t._v("同样，从技术上讲，Linux 是内核，其他都是附加软件。发行商也会在他们的项目中加入额外的软件。在这种情况下，有几个上游。一个发行版可以包含任何数量的应用程序，如 X、KDE、Gnome 等等。")]),t._v(" "),e("p",[t._v("让我们想象一下，你在使用 nano 编辑器时发现它不能正常工作，于是你向发行版提交了一份错误报告。发行商的程序员会查看它，如果发现他们在 nano 中插入了一个错误，他们将修复它并在其仓库中发布一个新版本。如果他们发现不是他们制造了这个错误，发行商将向上游的 nano 程序员提交一份错误报告。")]),t._v(" "),e("p",[t._v("当涉及到像错误报告、功能请求等事情时，最好是将它们发送到上游的发行商那里，因为他们维护着你所使用的发行版的内核和附加应用程序。例如，我在几台机器上使用一个叫做 Q4OS 的发行版。如果我发现一个程序中的错误，我会把它报告给 Q4OS 的人。如果你碰巧使用的是 Mint，你会把它报告给 Mint 项目。")]),t._v(" "),e("p",[t._v("比如说，如果你在一个普通的 Linux 论坛上发布一个问题，而你提到你在使用 Mint，你肯定会得到这样的回复。“这个问题最好在 Mint 论坛上处理”。用之前的 nano 错误的例子，有可能是 Mint 的程序员对 nano 进行了修改，使其在他们的发行版中运行得更好。如果他们确实犯了一个错误，他们会想知道这个错误，而且在犯了这个错误之后，他们会是修复它的人。")]),t._v(" "),e("p",[t._v("一旦修复，更新的程序就会被放入你可以使用的仓库。当你得到更新时，它就会顺流而下到你那里，像这样：")]),t._v(" "),e("p",[t._v("如果发行商进行了修复，新版本就会在发行仓库中提供。\n如果该应用程序的程序员进行了修复，它将被发送到测试新代码的发行商那里。一旦发现它工作正常，它就会被放在仓库中，向下游流去。")]),t._v(" "),e("h2",{attrs:{id:"自动流向下游"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自动流向下游"}},[t._v("#")]),t._v(" 自动流向下游")]),t._v(" "),e("p",[t._v("曾经有一段时间，用户得自己获取更新。用户会得到更新的源代码并编译一个新的可执行文件。随着时间的推移，像 apt 这样的工具被创造出来，允许用户从软件库中提取更新的二进制文件（可执行文件）。apt 程序是 Debian 的，但其他发行版也有他们自己的用于此用途的类似程序。")]),t._v(" "),e("p",[t._v("像 apt 这样的程序负责处理上游/下游的工作。如果你用升级选项运行 apt，像这样：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("sudo apt upgrade\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("它将查看（上游）发行仓库，找到任何需要的更新包，并将它们拉到你的机器上（下游）并安装它们。")]),t._v(" "),e("p",[t._v("有些发行版会更进一步。发行版的程序员和维护者总是在检查他们的产品。很多时候，应用程序的程序员会对他们的程序进行改进。系统库会经常更新，安全漏洞也会被堵上，等等。这些更新会提供给发行商，然后由发行商在发行仓库中提供新的版本。")]),t._v(" "),e("p",[t._v("与其让你每天运行 apt，一些发行版会提醒你有可用的更新并询问你是否需要它们。如果你想要，只要接受，更新就会被发送到你的机器上并安装。")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("上游和下游实际上只是数据流的方向。这个数据在上游或下游流动的方式取决于最终需要谁来处理它。基本上，程序员是上游，用户是下游。")]),t._v(" "),e("p",[t._v("同样，作为用户，我们真的不需要关心这些术语，但这些概念确实有助于软件的开发和维护。通过将工作引向适当的小组，避免了重复工作。这也确保了标准的维护。例如，Chrome 浏览器可能需要做一些细微的改变，以便在某个发行版上运行，但它的核心是 Chrome 浏览器，它的外观和行为都不会有大的变化。")]),t._v(" "),e("p",[t._v("如果你发现你的发行版中的任何程序有错误，只需向发行版的维护者报告，这通常是通过他们的网站进行的。你将会把它发送到上游，但你是否记得你在向上游发送报告并不重要。")])])}),[],!1,null,null,null);a.default=s.exports}}]);